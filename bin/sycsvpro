#!/usr/bin/env ruby
require 'gli'
begin # XXX: Remove this begin/rescue before distributing your app
require 'sycsvpro'
rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/sycsvpro` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/sycsvpro now"
  exit 64
end

include GLI::App

# Directory holding configuration files
sycsvpro_directory = File.expand_path("~/.syc/sycsvpro")

unless File.exists? sycsvpro_directory
  Dir.mkdir sycsvpro_directory
end

# Script directory
script_directory   = File.join(sycsvpro_directory, "scripts")

program_desc 'Processing CSV files'

version Sycsvpro::VERSION

desc 'CSV file to operate on'
arg_name 'FILE'
flag [:f,:file]

desc 'CSV file to write the result to'
arg_name 'OUT_FILE'
flag [:o, :out]

desc 'Silent progress doesn\'t show progress indicator'
switch [:s, :silent]

desc 'Analyze the CSV file regarding columns, rows and content'
command :analyze do |c|

  c.action do |global_options,options,args|
    print "Analyzing..."
    analyzer = Sycsvpro::Analyzer.new(global_options[:f])
    result = analyzer.result
    puts "done"
    puts "Analysis of #{global_options[:f]}"
    puts "#{result.col_count} columns: #{result.cols}"
    puts "#{result.row_count} rows"
    result.cols.each_with_index do |col, index|
      puts "#{index}: #{col}"
    end
    puts "Row sample data:"
    puts "#{result.sample_row}"
  end
end

desc 'Extract specified rows and columns from the file'
command :extract do |c|
  c.desc 'Rows to extract'
  c.arg_name '1,2,10-30,45-EOF,REGEXP'
  c.flag [:r, :row], :must_match => /\d+(?:,\d+|-\d+|-eof|,\/.*\/)*|\/.*\/(?:,\/.*\/|\d+)*/i

  c.desc 'Columns to extract'
  c.arg_name '1,2,10-30'
  c.flag [:c, :col], :must_match => /\d+(?:,\d+|-\d+)*/

  c.action do |global_options,options,args|
    print "Extracting ..."
    extractor = Sycsvpro::Extractor.new(infile: global_options[:f], outfile: global_options[:o],
                                        rows: options[:r], cols: options[:c])
    extractor.execute
    puts "done"    
  end
end

desc 'Collect values of specified rows and columns from the file and group them in categories'
command :collect do |c|

  c.desc 'Rows to consider for collection'
  c.arg_name 'ROW1,ROW2,ROW10-ROW30,45-EOF,REGEXP'
  c.flag [:r, :row], :must_match => /\d+(?:,\d+|-\d+|-eof|,\/.*\/)*|\/.*\/(?:,\/.*\/|\d+)*/i

  c.desc 'Columns to collect values from'
  c.arg_name 'CATEGORY1:COL1,COL2,COL10-COL30+CATEGORY2:COL3-COL9'
  c.flag [:c, :col], :must_match => /^\w*:\d+(?:,\d+|-\d+|\+\w*:\d+(?:,\d+|-\d+)*)*/

  c.action do |global_options,options,args|
    print "Collecting ..."
    collector = Sycsvpro::Collector.new(infile: global_options[:f], outfile: global_options[:o],
                                        rows: options[:r], cols: options[:c])
    collector.execute
    puts "done"    
  end
end

desc 'Allocate specified columns from the file to a key value'
command :allocate do |c|
  c.desc 'Rows to consider'
  c.arg_name '1,2,10-30,45-EOF,REGEXP'
  c.flag [:r, :row], :must_match => /\d+(?:,\d+|-\d+|-eof|,\/.*\/)*|\/.*\/(?:,\/.*\/|\d+)*/i

  c.desc 'Key to allocate columns to'
  c.arg_name '0'
  c.flag [:k, :key], :must_match => /\d+/

  c.desc 'Columns to allocate'
  c.arg_name '1,2,10-30'
  c.flag [:c, :col], :must_match => /\d+(?:,\d+|-\d+)*/

  c.action do |global_options,options,args|
    print "Allocating ..."
    allocator = Sycsvpro::Allocator.new(infile: global_options[:f], outfile: global_options[:o],
                                        key: options[:k], rows: options[:r], cols: options[:c])
    allocator.execute
    puts "done"    
  end
end

desc 'Creates a script/insert file or opens a script/insert file for editing if it exists'
command :edit do |c|
  c.desc 'Name of the script/insert file'
  c.arg_name 'SCRIPT_NAME.rb|INSERT_NAME.ins'
  c.flag [:s, :script], :must_match => /^\w+\.rb|^\w+\.ins/

  c.desc 'Method to create in combination with a script file'
  c.arg_name 'METHOD_NAME'
  c.flag [:m, :method], :must_match => /^\w+/

  c.action do |global_options,options,args|
    script_creator = Sycsvpro::ScriptCreator.new(dir: sycsvpro_directory, 
                                                 script: options[:s], method: options[:m])  
    system "vi #{script_creator.script_file}"
  end
end

desc 'Lists script or insert files in the scripts directory with optionally listing methods of script files'
command :list do |c|
  c.desc 'Type of script (Ruby or insert file)'
  c.default_value 'script'
  c.arg_name 'SCRIPT|INSERT'
  c.flag [:t, :type], :must_match => /script|insert/i

  c.desc 'Name of the script file'
  c.arg_name 'SCRIPT_NAME.rb|INSERT_NAME.ins'
  c.flag [:s, :script], :must_match => /^\w+\.rb|^\w+\.ins/

  c.desc 'Show methods'
  c.switch [:m, :method]

  c.action do |global_options,options,args|
    script_list = Sycsvpro::ScriptList.new(dir: script_directory, type: options[:t],
                                           script: options[:s], show_methods: options[:m])

    scripts = script_list.execute

    if scripts.empty?
      help_now! "No scripts available. You can create scripts with the edit command"
    else
      scripts.each do |script, methods|
        puts File.basename(script)
        methods.each do |method|
          puts method.gsub(/^/, "  ")
          puts
        end unless methods.empty?
      end
    end

  end
end

desc 'Executes the code provided in a file'
arg_name 'PRO_FILE METHOD'
command :execute do |c|
  c.action do |global_options,options,args|
    help_now! "You need to provide a script FILE and a METHOD to call" if args.size < 2

    script_file = File.expand_path(args[0])
    script_file = File.join(script_directory, args[0]) unless File.exists? script_file
    help_now! "Script file #{script_file} doesn't exist!" unless File.exists? script_file

    print "Executing..."
    profiler = Sycsvpro::Profiler.new(script_file)
    profiler.execute(args[1])
    puts "done"
  end
end

desc 'Counts the occurences of column values. Uses column values as headings with count as ' +
     'values. Columns with a condition will be added as new columns and the condition will ' +
     'be set as column name. Optionally adds a sum row'

command :count do |c|

  c.desc 'Key column that is assigned the count of column values to'
  c.arg_name 'KEY_COLUMN'
  c.flag [:k, :key], :must_match => /^\d+:\w+(?:,\d+:\w+)*/

  c.desc 'Rows to consider'
  c.arg_name '1,2,10-30,45-EOF,REGEXP'
  c.flag [:r, :row], :must_match => /\d+(?:,\d+|-\d+|-eof|,\/.*\/)*|\/.*\/(?:,\/.*\/|\d+)*/i

  c.desc 'Columns to count where columns 2 and 3 are counted conditionally'
  c.arg_name '1,2:<14.2.2014,10-30,3:>10'
  c.flag [:c, :col], :must_match => /^\d+(?:,\d+|(?::[<=>]\d+.\d+.\d+|:\d+.\d+.\d+-\d+.\d+.\d+|:\/.*?\/|:[<=>]\d+|:\d+-\d+|-\d+)*)*/

  c.desc 'Adds a sum row with TITLE for the counted columns at the specified row position'
  c.arg_name 'SUM_ROW_TITLE:ROW,SUM_COL_TITLE'
  c.flag [:s, :sum], :must_match => /^\w+:\d+(?:,\w+)?|^\w+/

  c.desc 'Format of date values'
  c.arg_name '%d.%m.%Y|%m/%d/%Y|...'
  c.flag [:df]

  c.action do |global_options,options,args|
    print "Counting..."
    counter = Sycsvpro::Counter.new(infile: global_options[:f], outfile: global_options[:o], 
                                    key: options[:k], rows: options[:r], cols: options[:c],
                                    df: options[:df], sum: options[:s])
    counter.execute
    puts "done"
  end

end

desc 'Aggregates the occurences of row values. Optionally adds a sum row'

command :aggregate do |c|

  c.desc 'Rows to consider'
  c.arg_name '1,2,10-30,45-EOF,REGEXP'
  c.flag [:r, :row], :must_match => /\d+(?:,\d+|-\d+|-eof|,\/.*\/)*|\/.*\/(?:,\/.*\/|\d+)*/i

  c.desc 'Columns to count'
  c.arg_name '1,2-4'
  c.flag [:c, :col], :must_match => /^\d+(?:,\d+|-\d+)*/

  c.desc 'Adds a sum row and a sum column with TITLE for the counted columns. The sum row is ' +
         'specified by the row position. The sum column is the last column in the row'
  c.arg_name 'SUM_ROW_TITLE:ROW,SUM_COL_TITLE'
  c.flag [:s, :sum], :must_match => /^\w+:\d+(?:,\w+)?|^\w+/

  c.action do |global_options,options,args|
    print "Aggregating..."
    aggregator = Sycsvpro::Aggregator.new(infile: global_options[:f], outfile: global_options[:o], 
                                          rows: options[:r], cols: options[:c], sum: options[:s])
    aggregator.execute
    puts "done"
  end

end

desc 'Sort rows based on column values'
command :sort do |c|
  c.desc 'Rows to consider'
  c.arg_name '1,2,10-30,45-EOF,REGEXP'
  c.flag [:r, :row], :must_match => /\d+(?:,\d+|-\d+|-eof|,\/.*\/)*|\/.*\/(?:,\/.*\/|\d+)*/i

  c.desc 'Columns to sort based on a type (n = number, s = string, d = date) and its value'
  c.arg_name 'n:1,s:2-5,d:7'
  c.flag [:c, :col], :must_match => /[d|n|s]:\d+(?:-\d+|,[d|n|s]:\d+)*/

  c.desc 'Format of date values'
  c.arg_name '%d.%m.%Y|%m/%d/%Y|...'
  c.default_value '%Y-%m-%d'
  c.flag [:df]

  c.desc 'File doesn\'t contain a header'
  c.switch [:h, :headerless]

  c.desc 'Sort order descending - default ascending'
  c.switch [:d, :desc]

  c.action do |global_options,options,args|
    sorter = Sycsvpro::Sorter.new(infile: global_options[:f], outfile: global_options[:o],
                                  rows: options[:r], cols: options[:c], df: options[:df],
                                  headerless: options[:h], desc: options[:d])
    print 'Sorting...'
    sorter.execute
    print 'done'
  end
end

desc 'Inserts rows from a file to a csv-file'
arg_name 'INSERT_FILE'
command :insert do |c|

  c.desc 'Position TOP or BOTTOM where to insert the rows'
  c.default_value 'top'
  c.arg_name 'top|bottom'
  c.flag [:p, :position], :must_match => /^top|^bottom/i

  c.action do |global_options,options,args|
    help_now! "You need to provide an insert file" if args.size == 0

    insert_file = File.expand_path(args[0])
    insert_file = File.join(script_directory, args[0])    unless File.exists? insert_file
    help_now! "Insert file #{insert_file} doesn't exist!" unless File.exists? insert_file

    print "Inserting..."
    inserter = Sycsvpro::Inserter.new(infile: global_options[:f], outfile: global_options[:o], 
                                      insert: insert_file, position: options[:p])
    inserter.execute
    puts "done"
  end
end

desc 'Map values in columns to new values'
arg_name 'MAPPINGS-FILE'
command :map do |c|
  c.desc 'Rows to consider'
  c.arg_name 'ROW1,ROW2,ROW10-ROW30,45-EOF,REGEXP'
  c.flag [:r, :row], :must_match => /\d+(?:,\d+|-\d+|-eof|,\/.*\/)*|\/.*\/(?:,\/.*\/|\d+)*/i

  c.desc 'Columns to consider for mapping'
  c.arg_name 'COL1,COL2,COL10-COL30'
  c.flag [:c, :col], :must_match => /\d+(?:,\d+|-\d+)*/

  c.action do |global_options,options,args|
    help_now! "You need to provide a mapping file" if args.size == 0

    print "Mapping..."
    mapper = Sycsvpro::Mapper.new(infile: global_options[:f], outfile: global_options[:o],
                                  mapping: args[0], rows: options[:r], cols: options[:c])
    mapper.execute
    puts "done"
  end
end

desc 'Process math operations on columns'
command :calc do |c|
    c.desc 'The first non-empty column is considered the header. '+
           'If additional columns are created then *,COL1,COL2 will create the additional header '+
           'columns COL1 and COL2'
    c.arg_name '*,COL2,COL2'
    default_value '*'
    c.flag [:h, :header], :must_match => /\*(?:,\w+)*/

    c.desc 'Columns to consider for calculations'
    c.arg_name 'ROW1,ROW2-ROW10,45-EOF,REGEXP'
    c.flag [:r, :row], :must_match => /\d+(?:,\d+|-\d+|-eof|,\/.*\/)*|\/.*\/(?:,\/.*\/|\d+)*/i

    c.desc 'Column to do calculations on'
    c.arg_name 'COL1:*2,COL2:-C3,COL3:*2+(4+C5),COL6:NEW_COL=C1+5'
    c.flag [:c, :col], :must_match => /\d+:(?:[\*\/\+\-]|\w+=[\d|(]*)[\*\/\+\-\dc()]*(?:,\d+:(?:[\*\/\+\-]|\w+=[\d|(]*)[\*\/\+\-\dc()]*)*/

  c.action do |global_options,options,args|
    help_now! "You need to provide the column flag" if options[:c].nil?

    print "Calculating..."
    calculator = Sycsvpro::Calculator.new(infile: global_options[:f], outfile: global_options[:o],
                                          header: options[:h], rows: options[:r], cols: options[:c])
    calculator.execute 
    puts "done"
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only

  case command.name
  when :analyze
    help_now! "You need to provide an input file '-f FILE'"     if global[:f].nil?
  when :aggregate, :allocate, :calc, :collect, :count, :extract, :map, :sort
    help_now! "You need to provide an input file '-f FILE'"     if global[:f].nil?
    help_now! "You need to provide a result file '-o OUT_FILE'" if global[:o].nil?
  end

  count = 0

  unless command.name == :edit or command.name == :execute or command.name == :list
    analyzer = Sycsvpro::Analyzer.new(global[:f])
    result = analyzer.result
    count = result.row_count
    set_max_row(options, count)
  end

  # Creates statistics on the command operation
  Stats = Struct.new(:command, :start, :end, :count) do
    # Calcualates the total duration
    def duration
      self.end - self.start
    end

    # Calculates the average time per row processing
    def average
      if count > 0
        (self.end - self.start) * 1000 / self.count
      else
        0
      end
    end

    # Prints the statistics
    def to_s
      if count > 0
        sprintf("%s %.5f %s %d %s %.5f %s", "'#{self.command}' has run",  
                                             duration,
                                             "seconds to operate",
                                             self.count,
                                             "rows -",
                                             average,
                                             "ms per row")
      else
        sprintf("%s %.5f %s", "'#{self.command}' has run",
                            duration,
                            "seconds")
      end
    end
  end

  @stats = Stats.new(command.name, Time.now, Time.now, count)

  unless command.name == :edit or global[:s]
    progress = Thread.new do
      sleep 3
      while true
        print '.'
        sleep 1
      end
    end
  end

  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
  puts

  @stats.end = Time.now
  unless command.name == :edit
    puts @stats
  end
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

def set_max_row(options, max_row)
  options.each do |option, value|
    case option
    when "r", :r, "row", :row
      options[option] = options[option].sub(/EOF/i, max_row.to_s) if options[option] =~ /EOF/i
    end
  end
end

exit run(ARGV)
